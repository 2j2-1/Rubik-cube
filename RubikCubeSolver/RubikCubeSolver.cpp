#include "stdafx.h"
#include <iostream>
#include <time.h>
#include "Movement.h"
#include "cGame.h"
#include <string>
#include <fstream>

//CONFIG
int boxSize = 20;
int cubeX = 9;
int cubeY = 4;

// Cube is a two dimesional array intiziallised with a "solved" cube
int cube[][9] = { { 1, 2, 3, 4, 5, 6, 7, 8, 9 },
				{ 10,11,12,13,14,15,16,17,18 },
				{ 19,20,21,22,23,24,25,26,27 },
				{ 28,29,30,31,32,33,34,35,36 },
				{ 37,38,39,40,41,42,43,44,45 },
				{ 46,47,48,49,50,51,52,53,54 } };

// Game is a command line graphical libary 
cGame game;
int locations[][6] = { { 3,0 },{ 0,3 },{ 3,3 },{ 6,3 },{ 9,3 },{ 3,6 } };
// Symbols are replaced later with colors so there are no able to be written to screen in other instances
char symbols[] = { '!','"','#','$','%','&' };
int amountOfMoves = 0;


int colors_to_cube(std::string cubeColors) {
	// this function is used to covert a cube of colors to a two diensional array of a vaild cube
	// the format to be given to this function is "yyyyyyyyybbbbbbbbbrrrrrrrrrgggggggggooooooooowwwwwwwww" this would produce a solved cube
	
	/*
	pairs is the postions that cover a cube eg top left corner is attached to yelow blue and orange
	Edges are just its self and the edge it is next to but corners are generated by placing a cube faceing forward and rotating so
	the front face is always forward and the number desired is in the top left the numbers are then read anti clockwise
	to keep it consistant no matter where it is rotated to
	*/
	int pairs[][3] = {
		{ 1,10 },{ 2,38 },{ 3,37 },{ 4,11 },{},{ 6,29 },{ 7,19 },{ 8,20 },{ 9,28 },
		{ 10,39 },{ 11,4 },{ 12,7 },{ 13,42 },{},{ 15,22 },{ 16,52 },{ 17,49 },{ 18,25 },
		{ 19,12 },{ 20,8 },{ 21,9 },{ 22,15 },{},{ 24,31 },{ 25,46 },{ 26,47 },{ 27,34 },
		{ 28,21 },{ 29,6 },{ 30,3 },{ 31,24 },{},{ 33,40 },{ 34,48 },{ 35,51 },{ 36,43 },
		{ 37,30 },{ 38,2 },{ 39,1 },{ 40,33 },{},{ 42,13 },{ 43,54 },{ 44,53 },{ 45,16 },
		{ 46,18 },{ 47,26 },{ 48,27 },{ 49,17 },{},{ 51,35 },{ 52,45 },{ 53,44 },{ 54,36 },
	};

	/*
	realtions is how the postions is determined it looks up the face of the first color and then the postion in that array of the second color
	for example a yellow face with a blue face connected will give the index [0][1] as the yellow number connected to blue is always 4
	this works for any color
	*/
	int realtions[][6] = { 
	{ 0,4,8,6,2,0 },
	{ 11,0,15,0,13,17 },
	{ 20,22,0, 24,0, 26 },
	{ 29,0,31,35,33,35 },
	{ 38,42,0,40,0,44 },
	{ 51,49,47,51,53,0 } };
	// triple raltions works the same as realtions but for corners
	int tripleRealtions[][6] = {
		{ 0,1,7,9,3,0 },
		{12,0,18,0,10,16},
		{21,19,0,27,0,25},
		{30,0,28,0,36,34},
		{39,45,0,37,0,43},
		{0,46,48,54,52,0},
	};
	//colors in the order they are in the cube
	char * aColors = "ybrgow";
	int colors[54];

	// converts cube of colors to there equivlent face postions
	for (int i = 0; i < 54; i++)
		for (int j = 0; j < 6; j++)
			if (cubeColors[i] == aColors[j]) {
				colors[i] = j;
				break;
			}

	// find the realtion number of every postions of the cube
	for (int i = 0; i < 54; i++) {
		//centers are just set
		if (i % 9 == 4)
			cube[i / 9][i % 9] = i + 1;

		/*
		Edges and corners are set by taking indexing realtions with the index of colors with the index of the cube postions
		eg when i is 0 and lets assume the cube is in the state yoywybogygbwobobrrbyoyrggggbrbwgwyywrgrrobgowwroywbrwo
		pairs is index for its first element this will return [1,10]
		postion 1-1 is index in the cube and returns "y" which has been replaced with 0
		postion 10-1 is indexed and returns "b" which has been replaced with 1
		as it is a corners (This is detrimined by the function (i % 9) % 2 as it find the nature of a piece by seeing if its odd or even) 
		tripleRealtions is then indexed with [0][1] which returns 1
		this process is continued though the whole cube
		*/

		else if ((i % 9) % 2 == 1)
			cube[i / 9][i % 9] = realtions[colors[pairs[i][0] - 1]][colors[pairs[i][1] - 1]];
		else
			cube[i / 9][i % 9] = tripleRealtions[colors[pairs[i][0] - 1]][colors[pairs[i][1] - 1]];
	}

	return 0;
}

// This displayd the stats at the upper right of the screen
void updateScreen() {
	game.print("Stats", game.screenWidth - boxSize, 0);
	game.print("Moves:", game.screenWidth - boxSize, 2);
	// It is converted to a string to get its length so it does not go over the edge of the sceen 
	std::string moveString = std::to_string(amountOfMoves);
	game.draw_pixel(game.screenWidth - 2, 2, '0');
	game.print(moveString, game.screenWidth - moveString.length(), 2);

}

void print_cube() {
	// Draws each cube in size cubeX by cube Y
	for (int i = 0; i < 54; i++)
		for (int j = 0; j < cubeX*cubeY; j++)
			if (cube[i / 9][i % 9] != 0)
				game.draw_pixel(
				//This find the X coordinate for each section of the cube to be drawn at
				((i % 3) * (cubeX + 1)) + j % cubeX + locations[i / 9][0] * (cubeX + 1),
				//This find the Y
				(((i % 9) / 3) * (cubeY + 1)) + j / cubeX + locations[i / 9][1] * (cubeY + 1),
				//This determins what symbol shuld be drawn for what color face it is
					symbols[(cube[i / 9][i % 9] - 1) / 9]);
	
	updateScreen();
	amountOfMoves++;
	game.draw(cubeX);
}

int main() {
	//Option 1 allow for a python script to be ran to input the cubes colors
	//Option 2 scrambles a solved cube with a standard 40 move scramble 
	//Option 3 loads a previously generated colored cube
	int choice = 0;
	std::cout << "1.Video input\n2.Scramble\n3.Exsiting file" << std::endl;
	std::cin >> choice;
	std::cin.ignore();
	//choice = 3;
	if (choice == 1)
		system("python video_to_colors.py");
	if (choice == 2) {
		srand(time(NULL));
		scramble(cube, 40);
		amountOfMoves = 0;
	}
	else {
		std::string line;
		std::ifstream myfile("Colors.txt");
		if (myfile.is_open()) {
			myfile >> line;
			if (line.length() == 54) {
				myfile.close();
				colors_to_cube(line);
			}
			else {
				std::cout << "Length " << line.length() << " is invalid, length 54 needed." << std::endl;
				std::cin.get();
				return 0;
			}
		}
		else {
			std::cout << "Problem loading file" << std::endl;
			std::cin.get();
			return 0;
		}
	}
	
	
	
	game.setup();
	game.blank_screen();
	print_cube();
	Sleep(1000);
	solve(cube);
	Sleep(5000);
}